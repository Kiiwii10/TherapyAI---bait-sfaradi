package com.example.therapyai.util;

import android.util.Base64;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class AESUtil {
    private static final String TAG = "AESUtil";

    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_TAG_LENGTH_BITS = 128; // 128 bits (16 bytes) for GCM authentication tag
    
    public static final int GCM_IV_LENGTH = 12; // 96 bits is standard for GCM
    public static final int GCM_TAG_LENGTH = 128; // 128 bits (16 bytes) is standard for GCM

    private static final int SALT_LENGTH = 16;
    private static final int LEGACY_IV_LENGTH = 16; // For CBC mode if used elsewhere
    private static final int PBKDF2_ITERATIONS = 65536;
    private static final int KEY_LENGTH_BITS = 256;


    /**
     * Encrypt data with AES/GCM, the Cipher will generate a new random IV.
     * Returns [IV + ciphertext].
     * This IV is for the data being encrypted (e.g., the DEK itself).
     */
    public static byte[] encryptAesGcm(byte[] plainData, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        // IV is generated by the cipher provider when key is passed
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] iv = cipher.getIV(); // Retrieve the generated IV (typically 12 bytes for GCM)
        if (iv == null || iv.length != GCM_IV_LENGTH) {
            throw new SecurityException("Generated IV is not of the expected GCM length (" + GCM_IV_LENGTH + " bytes). IV length: " + (iv != null ? iv.length : "null"));
        }

        byte[] cipherText = cipher.doFinal(plainData);

        byte[] combined = new byte[iv.length + cipherText.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(cipherText, 0, combined, iv.length, cipherText.length);
        Log.d(TAG, "encryptAesGcm: Input data length: " + plainData.length + ", IV length: " + iv.length + ", Ciphertext length: " + cipherText.length + ", Combined length: " + combined.length);
        return combined;
    }


    /**
     * Decrypt data previously encrypted by encryptAesGcm.
     * Expects [IV + ciphertext] as input.
     * The IV used here is the one that was prepended to the ciphertext (e.g., the DEK's IV).
     */
    public static byte[] decryptAesGcm(byte[] combinedIvCipherText, SecretKey key) throws Exception {
        if (combinedIvCipherText == null || combinedIvCipherText.length < GCM_IV_LENGTH) {
            throw new IllegalArgumentException("Combined IV and CipherText is null or too short to contain an IV.");
        }
        byte[] iv = Arrays.copyOfRange(combinedIvCipherText, 0, GCM_IV_LENGTH);
        byte[] cipherText = Arrays.copyOfRange(combinedIvCipherText, GCM_IV_LENGTH, combinedIvCipherText.length);

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);
        Log.d(TAG, "decryptAesGcm: Combined length: " + combinedIvCipherText.length + ", IV length: " + iv.length + ", Ciphertext length: " + cipherText.length);
        return cipher.doFinal(cipherText);
    }


    /**
     * Encrypts an input file to an output file using AES/GCM with the provided secret key.
     * Generates a new IV for each encryption and prepends it to the output file.
     * This is suitable for encrypting the audio file if not done via direct CipherOutputStream.
     */
    public static void encryptFile(File inputFile, File outputFile, SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey); // Let cipher generate IV
        byte[] iv = cipher.getIV();
        if (iv == null || iv.length != GCM_IV_LENGTH) {
            throw new SecurityException("Generated IV for file encryption is not of the expected GCM length.");
        }

        try (FileInputStream fis = new FileInputStream(inputFile);
             FileOutputStream fos = new FileOutputStream(outputFile)) {
            fos.write(iv); // Prepend IV
            try (CipherOutputStream cos = new CipherOutputStream(fos, cipher)) {
                byte[] buffer = new byte[8192];
                int read;
                while ((read = fis.read(buffer)) != -1) {
                    cos.write(buffer, 0, read);
                }
                cos.flush();
            }
        }
    }

    /**
     * Decrypts a single encrypted file (standard format) using streaming to avoid OOM.
     * This is used for the new multi-file approach where each segment is independently encrypted.
     */
    public static void decryptFile(File encryptedFile, File outputFile, SecretKey key) throws Exception {
        Log.d(TAG, "Decrypting single-segment file using streaming approach");
        decryptSingleSegmentFileStreaming(encryptedFile, outputFile, key);
    }
    
    /**
     * Decrypts a single-segment file with streaming to avoid OOM
     * Simple approach for independent encrypted files (multi-file approach)
     */
    private static void decryptSingleSegmentFileStreaming(File encryptedFile, File outputFile, SecretKey key) throws Exception {
        try (FileInputStream fis = new FileInputStream(encryptedFile);
             FileOutputStream fos = new FileOutputStream(outputFile)) {
            
            // Read IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            int ivBytesRead = fis.read(iv);
            if (ivBytesRead != GCM_IV_LENGTH) {
                throw new SecurityException("Cannot read IV from encrypted file");
            }
            
            // Create cipher and decrypt remaining data
            Cipher cipher = createDecryptionCipher(key, iv);
            
            // Use smaller buffer to prevent OOM
            byte[] buffer = new byte[64 * 1024]; // 64KB chunks
            long totalBytesProcessed = 0;
            long fileSize = encryptedFile.length() - GCM_IV_LENGTH; // Subtract IV size
            
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                totalBytesProcessed += bytesRead;
                
                // Check if this is likely the last chunk
                boolean isLastChunk = (totalBytesProcessed >= fileSize) || (fis.available() == 0);
                
                if (isLastChunk) {
                    // Use doFinal for the last chunk
                    try {
                        byte[] decrypted = cipher.doFinal(buffer, 0, bytesRead);
                        if (decrypted != null && decrypted.length > 0) {
                            fos.write(decrypted);
                            Arrays.fill(decrypted, (byte) 0);
                        }
                        break;
                    } catch (Exception e) {
                        // If doFinal fails, fall back to update
                        Log.d(TAG, "doFinal failed on last chunk, using update: " + e.getMessage());
                        byte[] decrypted = cipher.update(buffer, 0, bytesRead);
                        if (decrypted != null && decrypted.length > 0) {
                            fos.write(decrypted);
                            Arrays.fill(decrypted, (byte) 0);
                        }
                    }
                } else {
                    // Use update for intermediate chunks
                    byte[] decrypted = cipher.update(buffer, 0, bytesRead);
                    if (decrypted != null && decrypted.length > 0) {
                        fos.write(decrypted);
                        Arrays.fill(decrypted, (byte) 0);
                    }
                }
                
                // Clear buffer
                Arrays.fill(buffer, 0, bytesRead, (byte) 0);
            }
            
            // Try final call if we haven't done it yet
            try {
                byte[] finalData = cipher.doFinal();
                if (finalData != null && finalData.length > 0) {
                    fos.write(finalData);
                    Arrays.fill(finalData, (byte) 0);
                }
            } catch (Exception e) {
                Log.d(TAG, "Final doFinal completed or already called: " + e.getMessage());
            }
            
            Arrays.fill(iv, (byte) 0);
            Arrays.fill(buffer, (byte) 0);
            
            Log.d(TAG, "Successfully decrypted single-segment file. Total bytes: " + totalBytesProcessed);
        }
    }
    

    private static Cipher createDecryptionCipher(SecretKey key, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, gcmSpec);
        return cipher;
    }


    public static void secureDelete(File file) {
        if (file == null || !file.exists()) return;
        try {
            // Overwrite with random data first (simple approach)
            if (file.length() > 0) { // Check if file has content to overwrite
                SecureRandom random = new SecureRandom();
                try (FileOutputStream fos = new FileOutputStream(file)) {
                    byte[] overwriteBuffer = new byte[4096];
                    long bytesOverwritten = 0;
                    while (bytesOverwritten < file.length()) {
                        random.nextBytes(overwriteBuffer);
                        long remaining = file.length() - bytesOverwritten;
                        int toWrite = (int) Math.min(overwriteBuffer.length, remaining);
                        fos.write(overwriteBuffer, 0, toWrite);
                        bytesOverwritten += toWrite;
                    }
                    fos.flush(); // Ensure data is written
                    fos.getFD().sync(); // Sync to disk
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error overwriting file for secure delete: " + file.getAbsolutePath(), e);
        } finally {
            // Attempt to delete regardless of overwrite success
            if (!file.delete()) {
                Log.w(TAG, "Failed to delete file after attempting secure overwrite: " + file.getAbsolutePath());
            } else {
                Log.d(TAG, "Successfully deleted file: " + file.getAbsolutePath());
            }
        }
    }
    /**
     * Creates a CipherInputStream for decrypting an encrypted InputStream.
     * Reads the IV (GCM_IV_LENGTH bytes) from the beginning of the encryptedInputStream.
     * Uses the provided secretKey (this would be the plaintext DEK for audio).
     */
    public static CipherInputStream createDecryptingInputStream(InputStream encryptedInputStream, SecretKey secretKey) throws Exception {
        byte[] iv = new byte[GCM_IV_LENGTH];
        int totalBytesRead = 0;
        
        // Robust IV reading - ensure we read exactly GCM_IV_LENGTH bytes
        while (totalBytesRead < GCM_IV_LENGTH) {
            int bytesRead = encryptedInputStream.read(iv, totalBytesRead, GCM_IV_LENGTH - totalBytesRead);
            if (bytesRead == -1) {
                throw new IOException("Encrypted stream ended before complete IV could be read. Expected " + GCM_IV_LENGTH + ", got " + totalBytesRead);
            }
            totalBytesRead += bytesRead;
        }
        
        Log.d(TAG, "AESUtil: Read Audio IV for decryption (first " + GCM_IV_LENGTH + " bytes of stream): " + Base64.encodeToString(iv, Base64.NO_WRAP));

        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);

        return new CipherInputStream(encryptedInputStream, cipher);
    }
    public static SecretKey generateRandomAesKey() throws NoSuchAlgorithmException {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(KEY_LENGTH_BITS); // AES-256
        return keyGen.generateKey();
    }

    /**
     * Creates a Cipher configured for encryption with AES/GCM.
     * The Cipher will generate its own IV when initialized.
     * This is suitable for use with CipherOutputStream for real-time encryption.
     * @param secretKey The key to use for encryption
     * @return A Cipher configured for encryption mode
     * @throws Exception If cipher initialization fails
     */
    public static Cipher createEncryptionCipher(SecretKey secretKey) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return cipher;
    }

    // --- Legacy CBC methods (for QR code - keep as is if used elsewhere) ---
    public static String encrypt(String plainText, String passphrase) throws Exception {
        byte[] salt = new byte[SALT_LENGTH];
        new SecureRandom().nextBytes(salt);
        SecretKey secretKey = deriveKey(passphrase, salt);
        byte[] iv = new byte[LEGACY_IV_LENGTH]; // Use LEGACY_IV_LENGTH for CBC
        new SecureRandom().nextBytes(iv);
        IvParameterSpec ivParam = new IvParameterSpec(iv);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParam);
        byte[] ciphertext = cipher.doFinal(plainText.getBytes("UTF-8"));
        byte[] combined = new byte[salt.length + iv.length + ciphertext.length];
        System.arraycopy(salt, 0, combined, 0, salt.length);
        System.arraycopy(iv, 0, combined, salt.length, iv.length);
        System.arraycopy(ciphertext, 0, combined, salt.length + iv.length, ciphertext.length);
        return Base64.encodeToString(combined, Base64.NO_WRAP);
    }

    public static String decrypt(String base64Data, String passphrase) throws Exception {
        byte[] combined = Base64.decode(base64Data, Base64.NO_WRAP);
        byte[] salt = new byte[SALT_LENGTH];
        byte[] iv = new byte[LEGACY_IV_LENGTH]; // Use LEGACY_IV_LENGTH for CBC
        byte[] ciphertext = new byte[combined.length - SALT_LENGTH - iv.length];
        System.arraycopy(combined, 0, salt, 0, SALT_LENGTH);
        System.arraycopy(combined, SALT_LENGTH, iv, 0, iv.length);
        System.arraycopy(combined, SALT_LENGTH + iv.length, ciphertext, 0, ciphertext.length);
        SecretKey secretKey = deriveKey(passphrase, salt);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] decrypted = cipher.doFinal(ciphertext);
        return new String(decrypted, "UTF-8");
    }

    private static SecretKey deriveKey(String passphrase, byte[] salt) throws Exception {
        KeySpec spec = new PBEKeySpec(passphrase.toCharArray(), salt, PBKDF2_ITERATIONS, KEY_LENGTH_BITS);
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        byte[] keyBytes = factory.generateSecret(spec).getEncoded();
        return new SecretKeySpec(keyBytes, "AES");
    }

    /**
     * Validates that a file can be encrypted and then decrypted correctly.
     * This is useful for testing the encryption pipeline.
     * @param testFile The file to test with
     * @param secretKey The key to use for encryption/decryption
     * @return true if the round-trip encryption/decryption preserves the file content
     */
    public static boolean validateEncryptionPipeline(File testFile, SecretKey secretKey) {
        File encryptedFile = null;
        File decryptedFile = null;
        try {
            // Create temporary files
            encryptedFile = new File(testFile.getParent(), "test_encrypted_" + System.currentTimeMillis() + ".aes");
            decryptedFile = new File(testFile.getParent(), "test_decrypted_" + System.currentTimeMillis() + ".tmp");
            
            // Encrypt the file
            encryptFile(testFile, encryptedFile, secretKey);
            
            // Decrypt the file
            decryptFile(encryptedFile, decryptedFile, secretKey);
            
            // Compare original and decrypted files
            if (testFile.length() != decryptedFile.length()) {
                Log.e(TAG, "Validation failed: File sizes don't match. Original: " + testFile.length() + ", Decrypted: " + decryptedFile.length());
                return false;
            }
            
            // Simple byte-by-byte comparison
            try (FileInputStream originalFis = new FileInputStream(testFile);
                 FileInputStream decryptedFis = new FileInputStream(decryptedFile)) {
                byte[] originalBuffer = new byte[8192];
                byte[] decryptedBuffer = new byte[8192];
                int originalRead, decryptedRead;
                
                while ((originalRead = originalFis.read(originalBuffer)) != -1) {
                    decryptedRead = decryptedFis.read(decryptedBuffer);
                    if (originalRead != decryptedRead) {
                        Log.e(TAG, "Validation failed: Read lengths don't match");
                        return false;
                    }
                    for (int i = 0; i < originalRead; i++) {
                        if (originalBuffer[i] != decryptedBuffer[i]) {
                            Log.e(TAG, "Validation failed: File content differs at position " + i);
                            return false;
                        }
                    }
                }
                
                // Check if decrypted file has more data
                if (decryptedFis.read() != -1) {
                    Log.e(TAG, "Validation failed: Decrypted file has more data than original");
                    return false;
                }
            }
            
            Log.d(TAG, "Validation successful: Encryption/decryption pipeline preserves file content");
            return true;
            
        } catch (Exception e) {
            Log.e(TAG, "Validation failed with exception", e);
            return false;
        } finally {
            // Clean up temporary files
            if (encryptedFile != null && encryptedFile.exists()) {
                secureDelete(encryptedFile);
            }
            if (decryptedFile != null && decryptedFile.exists()) {
                secureDelete(decryptedFile);
            }
        }
    }
}